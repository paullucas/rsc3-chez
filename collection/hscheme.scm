(module hscheme r5rs (#%provide all all-true any append2 break gt lt eq compare compose concat concat-map const curry delete-by delete drop drop-while elem elem-index elem-indices enum-from-then-to enum-from-to even find find-index find-indices filter flip foldl foldl1 foldr foldr1 fst head id init insert insert-by intercalate intersperse is-infix-of is-prefix-of is-suffix-of last list1 list2 list3 lookup map1 map-accum-l map-accum-r maximum minimum nub nub-by nil not-elem null odd any-true otherwise partition pred product replicate scanl scanl1 scanr scanr1 snd span split-at succ sum tail take take-while transpose tuple1 tuple2 tuple3 uncurry undefined unfoldr union union-by zip zip3 zip-with zip-with3) (define all (lambda (f l) (if (null? l) #t (and (f (head l)) (all f (tail l)))))) (define all-true (lambda (l) (if (null? l) #t (and (head l) (all-true (tail l)))))) (define any (lambda (f l) (if (null? l) #f (or (f (head l)) (any f (tail l)))))) (define append2 (lambda (a b) (if (null? a) b (cons (head a) (append2 (tail a) b))))) (define break (lambda (p l) (span (compose not p) l))) (define gt (quote gt)) (define lt (quote lt)) (define eq (quote eq)) (define compare (lambda (x y) (cond ((> x y) gt) ((< x y) lt) (else eq)))) (define compose (lambda (f g) (lambda (x) (f (g x))))) (define concat (lambda (l) (foldr append2 nil l))) (define concat-map (lambda (f l) (concat (map1 f l)))) (define const (lambda (x) (lambda (_) x))) (define curry (lambda (f) (lambda (x y) (f (tuple2 x y))))) (define delete-by (lambda (f x l) (if (null? l) nil (if (f x (head l)) (tail l) (cons (head l) (delete-by f x (tail l))))))) (define delete (lambda (x l) (delete-by equal? x l))) (define drop (lambda (n l) (cond ((<= n 0) l) ((null? l) nil) (else (drop (- n 1) (tail l)))))) (define drop-while (lambda (p l) (if (null? l) nil (if (p (head l)) (drop-while p (tail l)) l)))) (define elem (lambda (x l) (any (lambda (y) (equal? x y)) l))) (define elem-index (lambda (x l) (find-index (lambda (y) (equal? x y)) l))) (define elem-indices (lambda (x l) (find-indices (lambda (y) (equal? x y)) l))) (define enum-from-then-to (lambda (i j k) (cond ((= i k) (list1 k)) ((> i k) nil) (else (cons i (enum-from-then-to j (+ j (- j i)) k)))))) (define enum-from-to (lambda (i j) (enum-from-then-to i (succ i) j))) (define even (lambda (n) (even? n))) (define find (lambda (f l) (if (null? l) #f (if (f (head l)) (head l) (find f (tail l)))))) (define find-index (letrec ((g (lambda (f l n) (if (null? l) #f (if (f (head l)) n (g f (tail l) (+ n 1))))))) (lambda (f l) (g f l 0)))) (define find-indices (letrec ((g (lambda (f l n) (if (null? l) nil (if (f (head l)) (cons n (g f (tail l) (+ n 1))) (g f (tail l) (+ n 1))))))) (lambda (f l) (g f l 0)))) (define filter (lambda (f l) (if (null? l) nil (let ((x (head l)) (xs (tail l))) (if (f x) (cons x (filter f xs)) (filter f xs)))))) (define flip (lambda (f) (lambda (x y) (f y x)))) (define foldl (lambda (f z l) (if (null? l) z (foldl f (f z (head l)) (tail l))))) (define foldl1 (lambda (f l) (foldl f (head l) (tail l)))) (define foldr (lambda (f z l) (if (null? l) z (f (head l) (foldr f z (tail l)))))) (define foldr1 (lambda (f l) (if (null? (tail l)) (head l) (f (head l) (foldr1 f (tail l)))))) (define fst (lambda (v) (vector-ref v 0))) (define head car) (define id (lambda (x) x)) (define init (lambda (l) (let ((x (head l)) (xs (tail l))) (if (null? xs) nil (cons x (init xs)))))) (define insert (lambda (e l) (insert-by compare e l))) (define insert-by (lambda (f x l) (if (null? l) (list1 x) (if (equal? (f x (head l)) gt) (cons (head l) (insert-by f x (tail l))) (cons x l))))) (define intercalate (lambda (xs xss) (concat (intersperse xs xss)))) (define intersperse (lambda (x l) (cond ((null? l) nil) ((null? (tail l)) l) (else (cons (head l) (cons x (intersperse x (tail l)))))))) (define is-infix-of (lambda (p q) (cond ((null? p) #t) ((null? q) #f) (else (or (is-prefix-of p q) (is-infix-of p (tail q))))))) (define is-prefix-of (lambda (p q) (cond ((null? p) #t) ((null? q) #f) (else (and (equal? (head p) (head q)) (is-prefix-of (tail p) (tail q))))))) (define is-suffix-of (lambda (p q) (is-prefix-of (reverse p) (reverse q)))) (define last (lambda (l) (let ((xs (tail l))) (if (null? xs) (head l) (last xs))))) (define list1 (lambda (x) (list x))) (define list2 (lambda (x y) (list x y))) (define list3 (lambda (x y z) (list x y z))) (define lookup (lambda (x l) (if (null? l) #f (if (equal? (fst (head l)) x) (snd (head l)) (lookup x (tail l)))))) (define map1 (lambda (f l) (if (null? l) nil (cons (f (head l)) (map1 f (tail l)))))) (define map-accum-l (lambda (f s l) (if (null? l) (tuple2 s nil) (let* ((x (head l)) (xs (tail l)) (s_y (f s x)) (s_ (fst s_y)) (y (snd s_y)) (s__ys (map-accum-l f s_ xs)) (s__ (fst s__ys)) (ys (snd s__ys))) (tuple2 s__ (cons y ys)))))) (define map-accum-r (lambda (f s l) (if (null? l) (tuple2 s nil) (let* ((x (head l)) (xs (tail l)) (s_ys (map-accum-r f s xs)) (s_ (fst s_ys)) (ys (snd s_ys)) (s__y (f s_ x)) (s__ (fst s__y)) (y (snd s__y))) (tuple2 s__ (cons y ys)))))) (define maximum (lambda (l) (foldl1 max l))) (define minimum (lambda (l) (foldl1 min l))) (define nub (lambda (l) (nub-by equal? l))) (define nub-by (lambda (f l) (if (null? l) nil (let ((x (head l)) (xs (tail l))) (cons x (nub-by f (filter (lambda (y) (not (f x y))) xs))))))) (define nil (list)) (define not-elem (lambda (x l) (all (lambda (y) (not (equal? x y))) l))) (define null null?) (define odd odd?) (define any-true (lambda (l) (if (null? l) #f (or (head l) (any-true (tail l)))))) (define otherwise #t) (define partition (let ((select (lambda (p) (lambda (x tf) (let ((t (fst tf)) (f (snd tf))) (if (p x) (tuple2 (cons x t) f) (tuple2 t (cons x f)))))))) (lambda (p xs) (foldr (select p) (tuple2 nil nil) xs)))) (define pred (lambda (x) (- x 1))) (define product (lambda (l) (foldl * 1 l))) (define replicate (lambda (n x) (if (= n 0) nil (cons x (replicate (- n 1) x))))) (define scanl (lambda (f q l) (cons q (if (null? l) nil (scanl f (f q (head l)) (tail l)))))) (define scanl1 (lambda (f l) (if (null? l) nil (scanl f (head l) (tail l))))) (define scanr (lambda (f q0 l) (if (null? l) (list1 q0) (let ((qs (scanr f q0 (tail l)))) (cons (f (head l) (head qs)) qs))))) (define scanr1 (lambda (f l) (if (null? l) nil (if (null? (tail l)) l (let ((qs (scanr1 f (tail l)))) (cons (f (head l) (head qs)) qs)))))) (define snd (lambda (v) (vector-ref v 1))) (define span (lambda (p l) (if (null? l) (tuple2 nil nil) (if (p (head l)) (let ((r (span p (tail l)))) (tuple2 (cons (head l) (fst r)) (snd r))) (tuple2 nil l))))) (define split-at (lambda (n l) (tuple2 (take n l) (drop n l)))) (define succ (lambda (x) (+ x 1))) (define sum (lambda (l) (foldl + 0 l))) (define tail cdr) (define take (lambda (n l) (cond ((<= n 0) nil) ((null? l) nil) (else (cons (head l) (take (- n 1) (tail l))))))) (define take-while (lambda (p l) (if (null? l) nil (if (p (head l)) (cons (head l) (take-while p (tail l))) nil)))) (define transpose (lambda (l) (let ((protect (lambda (f) (lambda (x) (if (null? x) nil (f x)))))) (cond ((null? l) nil) ((null? (head l)) (transpose (tail l))) (else (let* ((e (head l)) (x (head e)) (xs (tail e)) (xss (tail l))) (cons (cons x (filter (compose not null?) (map1 (protect head) xss))) (transpose (cons xs (map (protect tail) xss)))))))))) (define tuple1 (lambda (x) (vector x))) (define tuple2 (lambda (x y) (vector x y))) (define tuple3 (lambda (x y z) (vector x y z))) (define uncurry (lambda (f) (lambda (xy) (f (fst xy) (snd xy))))) (define undefined (lambda () (head nil))) (define unfoldr (lambda (f x) (let ((r (f x))) (if r (cons (fst r) (unfoldr f (snd r))) nil)))) (define union (lambda (a b) (union-by equal? a b))) (define union-by (lambda (f xs ys) (let ((g (lambda (x y) (delete-by f y x)))) (append2 xs (foldl g (nub-by f ys) xs))))) (define zip (lambda (a b) (zip-with tuple2 a b))) (define zip3 (lambda (a b c) (zip-with tuple3 a b c))) (define zip-with (lambda (f a b) (cond ((null? a) nil) ((null? b) nil) (else (cons (f (head a) (head b)) (zip-with f (tail a) (tail b))))))) (define zip-with3 (lambda (f a b c) (cond ((null? a) nil) ((null? b) nil) ((null? c) nil) (else (cons (f (head a) (head b) (head c)) (zip-with3 f (tail a) (tail b) (tail c))))))))