;; list.scm - (c) rohan drape, 2000-2007

(module list scheme/base

(require (only-in srfi/1
		  append-map
		  drop
		  iota
		  make-list
		  take))

(provide list-ref/wrap
	 length*
	 geom
	 filter-index
	 drop*
	 concat
	 foldr
	 foldl
	 foldl1
	 maximum
	 splice
	 interleave
	 intersperse
	 lace
	 extend
	 extend-all
	 rotate
	 invert
	 cycles
	 take-cycle)

;; list-ref variant where n is taken modulo the list length.

(define (list-ref/wrap l n)
  (list-ref l (modulo n (length l))))

;; length variant that returns 1 for non-list arguments.

(define (length* l)
  (if (list? l)
      (length l)
      1))

;; drop variant that returns the empty list if `n' is not less than
;; the length of the list `l'.

(define (drop* l n)
  (if (> (length l) n)
      (drop l n)
      (list)))

;; iota variant that makes a list of `n' places, the first is `init',
;; each subsequent is the previous multiplied by `factor'.

(define (geom n init factor)
  (if (= n 0)
      (list)
      (cons init (geom (- n 1) (* init factor) factor))))

;; filter variant that return a sub-list of `l' containing only those
;; elements at indices for which the procedure `predicate' evaluates
;; to '#t'.

(define (filter-index predicate l)
  (map (lambda (index) (list-ref l index))
       (filter predicate (iota (length l)))))

;; [Haskell Prelude]

;; (define (foldr f z l)
;;   (if (null? l)
;;       z
;;       (f (car l) (foldr f z (cdr l)))))

(define (concat l)
  (foldr append '() l))

;; (define (foldl f z l)
;;   (if (null? l)
;;       z
;;       (foldl f (f z (car l)) (cdr l))))

(define (foldl1 f l)
  (foldl f (car l) (cdr l)))

(define (maximum l)
  (foldl1 max l))

;; [sclang] Elements at `l' are spliced into a list.  This is a
;; non-recursive flatten operation.

(define (splice l)
  (let ((f (lambda (a b)
	     (if (list? a)
		 (append a b)
		 (cons a b)))))
    (foldr f '() l)))

;; Return a <list> that interleaves values from the <list>s at `l'.

(define (interleave . l)
  (apply append-map (lambda e e) l))

;; Insert `e' between elements of `list'.  Courtesy Oleg Kiselyov.

(define (intersperse list e)
  (if (null? list)
      list
      (let loop ((l (cdr list)) (dest (cons (car list) '())))
	(if (null? l)
	    (reverse dest)
	    (loop (cdr l) (cons (car l) (cons e dest)))))))

;; [sclang] An interleave variant that extends input lists to be of
;; equal length before interleaving.  The name is courtesy SC3.

(define (lace . l)
  (apply append-map (lambda e e) (extend-all l)))

;; [sclang] Return a list of `n' places.  If `l' is a list with fewer
;; than `n' elements returns the circular expansion of `l', if `l' is
;; a list with more than `n' elements returns only first `n' elements
;; of `l', if `l'is a list of `n' elements returns `l'.  If `l' is not
;; a list returns a list of `n' elements each being `l'.

(define (extend l n)
  (if (and (list? l) (not (null? l)))
      (let ((z (length l)))
	(cond ((= z n) l)
	      ((> z n) (take l n))
	      (else (extend (append l l) n))))
      (make-list n l)))

;; Extend all lists at `l' to be equal in length to the longest list
;; at `l'.  If any element is not a list it is replaced with a list of
;; itself of that length.

(define (extend-all l)
  (let ((n (apply max (map length* l))))
    (map (lambda (e) (extend e n)) l)))

;; Return a rotation of `l' by `n' places.

(define (rotate l n)
  (let ((ll (length l)))
    (map (lambda (index) (list-ref l (modulo (+ n index) ll)))
	 (iota ll))))

;; UNSAFE...

(define (invert l)
  (let ((f (lambda (n) (map (lambda (e) (list-ref e n)) l))))
    (map f (iota (length (car l))))))

;; Return a <list> containing every `n'th element of the list `l' in
;; sequence.

(define (take-cycle l n)
  (filter-index (lambda (i) (= 0 (modulo i n))) l))

;; Return a <list> of <list>s, each containing a cycle generated by
;; 'take-cycle'.

(define (cycles l n)
  (map (lambda (i)
	 (take-cycle (drop* l i) n))
       (iota n)))

)
