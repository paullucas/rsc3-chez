;; list.scm - (c) rohan drape, 2000-2006

;; Aliases for R5RS and SRFI-1 procedures.

(define ref       list-ref)
(define tail      list-tail)
(define tabulate  list-tabulate)
(define copy      list-copy)
(define index     list-index)

;; [R5RS+] Binary append.

(define (++ a b) (append a b))

;; [R5RS+] Return 1 for non-<list> arguments.

(define (length* l) (if (list? l) (length l) 1))

;; [R5RS+] Windowed map.  Apply 'f' to 'n' element windows with 'm'
;; separation at `l' having 'z' elements.

(define (mapwz n m f l z)
  (cond ((or (> n z) (> m z))
	 (error "mapwz: short list" n m f l z))
	((= n z)
	 (list (apply f l)))
	(else
	 (cons (apply f (take l n))
	       (mapwz n m f (drop l m) (- z m))))))

(define (mapw n m f l)
  (mapwz n m f l (length l)))

;; Variant that extends the list to (length l) + n - 1 places.

(define (mapw* n m f l)
  (mapw n m f (extend l (+ n -1 (length l)))))

;; [SRFI-1+] Generate {i,...,j-1}.

(define (iotaR i j) (iota (- j i) i))

;; [SRFI-1+] Generate a <list> of <number>s, the first is `seed', each
;; subsequent element is derived by multiplying the previous element
;; by `factor'.  The <list> halts before exceeding `limit'.

(define (iotaG seed factor limit)
  (unfold (lambda (x) (> x limit))
	  (lambda (x) x)
	  (lambda (x) (* x factor))
	  seed))

;; [SRFI-1+] Make a <list> of `n' places, the first is `init', each
;; subsequent is the previous multiplied by `factor'.

(define (geom n init factor)
  (if (= n 0) '() (cons init (geom (- n 1) (* init factor) factor))))

;; [SRFI-1+] Variant that applies to a <list> of <list>s.

(define (zipL l) (apply zip l))

;; [SRFI-1+] Variant that deletes left duplicates.

(define (delete-duplicates-left l . =)
  (reverse (delete-duplicates (reverse l) (if (null? =) equal? =))))

;; [SRFI-1+] Return the empty <list> if `n' is not less than the length
;; of the list `l'.

(define (drop* l n) (if (> (length l) n) (drop l n) '()))

;; [SRFI-13] Extend the <list> l to `n' places with `d'.

(define (pad-right l n d)
  (let ((i (length l)))
    (cond ((= i n) l)
	  ((> i n) (take l n))
	  (else (++ l (make-list (- n i) d))))))

;; [R5RS+] A true predicate form of 'member'.

(define (member? o l) (if (member o l) #t #f))

;; [SCLANG] Return a list of `n' places.  If `l' is a list with fewer
;; than `n' elements returns the circular expansion of `l', if `l' is
;; a list with more than `n' elements returns only first `n' elements
;; of `l', if `l'is a list of `n' elements returns `l'.  If `l' is not
;; a list returns a list of `n' elements each being `l'.

(define (extend l n)
  (if (and (list? l) (not (null? l)))
      (let ((z (length l)))
	(cond ((= z n) l)
	      ((> z n) (take l n))
	      (else (extend (++ l l) n))))
      (make-list n l)))

;; Extend all lists at `l' to be equal in length to the longest list
;; at `l'.  If any element is not a list it is replaced with a list of
;; itself of that length.

(define (extend-all l)
  (let ((n (apply max (map length* l))))
    (map (lambda (e) (extend e n)) l)))

;; [R5RS+] Return the element `n', modulo the length of `l', at `l'.

(define (ref/wrap l n) (ref l (modulo n (length l))))

;; Variant that wraps indices and allows non list input.

(define (ref/wrap* l n) (if (list? l) (ref/wrap l n) l))

;; Return the element `n' places from the end of `l'.

(define (ref-right l n)
  (ref l (- (- (length l) n) 1)))

;; Return a sub-list of `l' containing only those elements at indices
;; for which the procedure `predicate' evaluates to '#t'.

(define (filter-index predicate l)
  (map (lambda (index) (ref l index))
       (filter predicate (iota (length l)))))

;; Return a <list> containing every `n'th element of the list `l' in
;; sequence.

(define (take-cycle l n)
  (filter-index (lambda (i) (= 0 (modulo i n))) l))

;; Return a <list> of <list>s, each containing a cycle generated by
;; 'take-cycle'.

(define (cycles l n)
  (map (lambda (i)
	 (take-cycle (drop* l i) n))
       (iota n)))

;; Return a <list> that interleaves values from the <list>s at `l'.

(define (interleave . l) (apply append-map (lambda e e) l))

;; [SCLANG] An interleave variant that extends input lists to be of
;; equal length before interleaving.  The name is courtesy SC3.

(define (lace . l) (apply append-map (lambda e e) (extend-all l)))

;; [SCLANG] A zip variant that extends input lists to be of equal
;; length before zipping.  The name is courtesy SC3.

(define (flop . l) (apply map list (extend-all l)))

;; Remove all elements from the list `l' the indexes to which satisfy
;; predicate.

(define (remove-index p l)
  (fold-right (lambda (e i r) (if (p i) r (cons e r)))
	      '()
	      l (iota (length l))))

;; Remove at most `n' elements from the list `l' that satisfy the
;; predicate `p'.

(define (remove-count p l n)
  (if (null? l)
      '()
      (if (and (p (car l)) (> n 0))
	  (remove-count p (cdr l) (- n 1))
	  (cons (car l) (remove-count p (cdr l) n)))))

;; Delete at most `n' elements of `l' that are equal to `x' under the
;; test `p', or under 'equal?' if `p' is not given.

(define (delete-count x l n . p)
  (let ((test (if (null? p)
		  equal?
		  (car p))))
    (remove-count (lambda (e) (test x e)) l n)))

;; Return a rotation of `l' by `n' places.

(define (rotate l n)
  (let ((ll (length l)))
    (map (lambda (index) (ref l (modulo (+ n index) ll)))
	 (iota ll))))

(define (rotate-right l n) (rotate l (- n)))

;; Derivative of the map procedure. The `proc' procedure is applied to
;; the elements of the `l' and `more' lists *preceded* by the current
;; index.

(define (map/index proc l . more)
  (apply map proc (iota (length l)) l more))

;; Return a list derived from the proper list `l' by placing `object'
;; in `l' before the first element for which `predicate' evaluates to
;; '#t', or at the end of the list.

(define (insert l predicate object)
  (if (null? l)
      (cons object l)
      (if (predicate (car l))
	  (cons object l)
	  (cons (car l) (insert (cdr l) predicate object)))))

;; Return #t iff for all elements of `l' the given `f' is #t.

(define (uniform? f? l)
  (let ((x (car l))
	(xs (cdr l)))
    (cond ((null? xs) (f? x))
	  ((f? x)     (uniform? f? xs))
	  (else       #f))))

;; Return the index of the first element of `l' that is equal to `x'
;; under `=', which defaults to 'equal?', or '#f' if no element is
;; equal.

(define (index-equal x l =) (index (cut = <> x) l))

;; Return a string that contains the printed representations, as given
;; by 'display', of the objects at `list', delimited by the string
;; `delimiter'.

(define (list->delimited-string list delimiter)
  (fold-right string-append
	      ""
	      (map (lambda (e)
		     (format "~a" e))
		   (intersperse list delimiter))))

;; Return a list where every element at `l' is spliced into the result
;; list.  This is a non-recursive flatten operation.

(define (cons-or-++ a b) (if (list? a) (++ a b) (cons a b)))

(define (splice l) (foldr cons-or-++ '() l))

;; Variant that splices only sub-lists at `l' that satisy the
;; predicate `p'.

(define (splice-if l p)
  (if (null? l)
      '()
      (let ((next (car l)))
	(if (and (list? next) (p next))
	    (++ next (splice (cdr l)))
	    (cons next (splice (cdr l)))))))

;; Return the sublist of `list' from indices `left' to `right',
;; inclusive and exclusive.

(define (sublist list left right)
  (take (drop list left) (- right left)))

;; Insert `e' between elements of `list'.  Courtesy Oleg Kiselyov.

(define (intersperse list e)
  (if (null? list)
      list
      (let loop ((l (cdr list)) (dest (cons (car list) '())))
	(if (null? l)
	    (reverse dest)
	    (loop (cdr l) (cons (car l) (cons e dest)))))))

;; Return `l' as a palindrome.

(define (mirror l) (++ l (cdr (reverse l))))

;; Variant that removes the last element.  This is useful if the list
;; will be repeated cyclically.

(define (mirror1 l) (++ l (cdr (reverse (cdr l)))))

;; Variant that has center element duplicated.

(define (mirror2 l) (++ l (reverse l)))

;; Return a list that consists of `n' repetitions of `l'.

(define (repeat l n) (if (<= n 0) '() (++ l (repeat l (- n 1)))))

;; Predicate to determine if `l' is a one element list.

(define (singleton? l) (and (list? l) (null? (cdr l))))

;; Generate a function to compare to lists using the element
;; comparator `<'.  A short list will compare less than unless an
;; early element has compared greater than.

(define (make-list-comparator <)
  (lambda (a b)
    (let loop ((a* a) (b* b))
      (cond ((or (and (null? a*) (null? b*)) (null? b*))  #f)
	    ((or (null? a*) (< (car a*) (car b*))) #t)
	    (else (loop (cdr a*) (cdr b*)))))))

(define list-< (make-list-comparator <))

;; Binary math on <list>s.  {R,...} -> {R,...} -> {R,...}

(define (+l a b) (map + a b))
(define (*l a b) (map * a b))
(define (/l a b) (map / a b))
(define (-l a b) (map - a b))

;; Binary math on unary <function>s generating <list>s.
;; (a -> {R,...}) -> (a -> {R,...}) -> (a -> {R,...})

(define (+fl a b) (lambda (n) (+l (a n) (b n))))
(define (*fl a b) (lambda (n) (*l (a n) (b n))))
(define (/fl a b) (lambda (n) (/l (a n) (b n))))
(define (-fl a b) (lambda (n) (-l (a n) (b n))))

;; Binary math where a is a scalar and b a list.

(define (+> a b) (map (lambda (n) (+ n a)) b))
(define (*> a b) (map (lambda (n) (* n a)) b))
(define (/> a b) (map (lambda (n) (/ n a)) b))

;; List and scalar math.

(define (l+s l s) (map (lambda (n) (+ n s)) l))
(define (l*s l s) (map (lambda (n) (* n s)) l))
(define (l-s l s) (map (lambda (n) (- n s)) l))
(define (l/s l s) (map (lambda (n) (/ n s)) l))

(define (s+l s l) (map (lambda (n) (+ n s)) l))
(define (s*l s l) (map (lambda (n) (* n s)) l))
(define (s-l s l) (map (lambda (n) (- n s)) l))
(define (s/l s l) (map (lambda (n) (/ n s)) l))

;; Haskell variants.

(define head        car)
(define zipWith     map)
(define zipWith3    map)
(define elem        member)
(define all         every)
(define (minimum l) (foldl1 min l))
(define (maximum l) (foldl1 max l))
(define (concat l)  (fold ++ '() l))
(define num         delete-duplicates)
(define unzip       unzip2)
(define lookup      assoc)

(define (foldl f z l)
  (if (null? l)
      z
      (foldl f (f z (car l)) (cdr l))))

(define (foldl1 f l)
  (foldl f (car l) (cdr l)))

(define (scanl f q l)
  (cons q (if (null? l)
	      '()
	      (scanl f (f q (car l)) (cdr l)))))

(define (scanl1 f l)
  (scanl f (car l) (cdr l)))

(define (foldr f z l)
  (if (null? l) z (f (car l) (foldr f z (cdr l)))))

(define (foldr1 f l)
  (if (null? (cdr l)) (car l) (f (car l) (foldr1 f (cdr l)))))

(define (scanr f q0 l)
  (if (null? l)
      (list q0)
      (let ((qs (scanr f q0 (cdr l))))
	(cons (f (car l) (car qs)) qs))))

(define (scanr1 f l)
  (if (singleton? l)
      l
      (let ((qs (scanr1 f (cdr l))))
	(cons (f (car l) (car qs)) qs))))

;; List variants.

(define (as/l p)
  (lambda (value) (apply p value)))

(define (mapL p l) (map (as/l p) l))

(define (unfoldL p f g seed)
  (unfold (as/l p) (as/l f) (as/l g) seed))

;; UNSAFE...

(define (invert l)
  (let ((f (lambda (n) (map (lambda (e) (ref e n)) l))))
    (map f (iota (length (car l))))))
